//! Struct and methods to deal with probes
//!
use serde::{Serialize, Deserialize};
use ureq::{Error, Response};

use crate::client::Client;
use crate::common::add_opts;
use crate::errors::*;

/// Geolocation as reported by the probe
#[derive(Serialize, Deserialize, Debug)]
pub struct Geometry {
    #[serde(rename = "type")]
    pub gtype: String,
    pub coordinates: Vec<f64>,
}

/// Describes the current status of the probe
#[derive(Serialize, Deserialize, Debug)]
pub struct Status {
    pub since: String,
    pub id: u32,
    pub name: String,
}

/// Tags about the probe, most generated by the API, some you can add
#[derive(Serialize, Deserialize, Debug)]
pub struct Tags {
    pub name: String,
    pub slug: String,
}

/// All information about a given probe
#[derive(Serialize, Deserialize, Debug)]
pub struct Probe {
    pub address_v4: String,
    pub address_v6: String,
    pub asn_v4: u32,
    pub asn_v6: u32,
    pub country_code: String,
    pub description: String,
    pub geometry: Geometry,
    pub id: u32,
    pub is_anchor: bool,
    pub is_public: bool,
    pub last_connected: u32,
    pub prefix_v4: String,
    pub prefix_v6: String,
    pub status: Status,
    pub status_since: String,
    pub tags: Vec<Tags>,
    #[serde(rename = "type")]
    pub ptype: String,
}

/// When asking for a list of probes, this struct is used for pagination
#[derive(Serialize, Deserialize, Debug)]
pub struct ProbeList {
    pub count: u32,
    pub next: String,
    pub previous: String,
    pub probes: Vec<Probe>,
}

/// Main API methods for `Probe` type
impl<'cl> Client<'cl> {
    /// Get information on a specific probe by ID
    ///
    /// Examples:
    ///
    /// ```no_run
    ///  # use atlas_rs::client::Client;
    ///  # use atlas_rs::probes::Probe;
    ///
    ///     let cl = Client::new("foo").verbose(true);
    ///     let pi = cl.get_probe(666).unwrap();
    ///
    ///     println!("Probe ID {}: {}", 666, pi.description);
    ///  ```
    ///
    pub fn get_probe(&self, id: u32) -> Result<Probe, APIError> {
        let url = format!("{}/probe/{}", self.endpoint, id);

        let mut opts = self.opts.clone();
        opts.insert("key", self.api_key);

        let url = add_opts(&url, opts);

        let resp: ureq::Response = match self.agent.as_ref().unwrap().get(&url).call() {
            Ok(resp) => resp,
            Err(Error::Status(_code, resp)) => {
                let er = resp.into_string()?;
                let a = decode_error(&er).unwrap();
                return Err(a)
            },
            _ => {
                let err= APIError::new(500,
                                        "Bad",
                                        "unknown error",
                                        "get_probe");
                return Err(err)
            },
        };
        let resp = resp.into_string().unwrap();
        let p: Probe = serde_json::from_str(&resp)?;
        Ok(p)
    }

    /// Get information about a set of probes according to parameters
    ///
    pub fn get_probes() -> Result<ProbeList, APIError> {
        unimplemented!()
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_get_probe() {

    }
}
